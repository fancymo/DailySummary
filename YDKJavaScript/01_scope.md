编程语言最基本的能力是能够存储变量中的值，并能对这个值进行访问或修改。

- 变量存储在哪里？
- 程序需要时如何找到它们？

需要设计一套良好的规则来存储变量，之后可以方便的找到这些变量。这就是作用域。

### 1 编译原理

传统编译语言代码执行前会经历三个步骤：
- 分词/词法分析(Tokenizing/Lexing): 将字符组成的字符串分解成有意义的代码块，代码块被称为词法单元(token)。

```
var a = 2; // 词法单元 => var、a、=、2、; 空格是否被当作词法单元，取决于空格在这门语言中是否具有意义。
```

- 解析/语法分析(Parsing): 将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树(AST)。

- 代码生成: 将 AST 转换为可执行代码的过程。简单来说就是将 AST 转换为一组机器指令，用来创建 a 的变量(包括内存分配)，并将一个值存储在 a 中。

JavaScript 引擎要复杂的多，比如对运行性能进行优化，对冗余元素进行优化等。用尽各种方法（JIT，延迟编译甚至实施重编译）保证性能最佳。

### 2 作用域

相关概念：
- 引擎: 负责整个 JavaScript 的编译及执行过程。
- 编译器: 负责语法分析、代码生成等。
- 作用域: 负责收集并维护所有声明的标识符组成的一系列查询，并实施一套严格的规则，确定当前执行的代码对标识符的访问权限。

`var a = 2;`变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后运行时引擎会在作用域中查找该变量，如果能找到就会对它赋值。

编译器生成的代码，引擎执行时，会通过查找变量 a 来判断是否已经声明过，由作用域协助，引擎会为变量 a 进行 LHS 查询。

LHS 试图找到变量的容器本身，RHS 理解成 retrieve his source value（取到它的源值），意味着‘得到某某的值’。

ReferenceError 同作用域判别失败相关，TypeError 代表作用域判别成功，但对结果对操作是非法或不合理的:
- RHS 查询在所有嵌套作用域中遍寻不到所需的变量，引擎会抛出 ReferenceError;
- 严格模式下禁止自动或隐式创建全局变量，LHS 查询失败并不会返回一个全局变量，引擎抛出 ReferenceError;
- RHS 查询找到一个变量，尝试对变量的值进行不合理的操作，比如试图对一个非函数类型进行函数调用，会抛出 TypeError;

#### 2.1 词法作用域

词法作用域是定义在词法阶段的作用域，由写代码时将变量和块作用域写在哪里来决定的，词法分析器处理代码时会保持作用域不变。

作用域查找会在找到第一个匹配的标识符时停止。多层嵌套作用域可以定义同名的标识符，叫‘遮蔽效应’。


##### 2.1.1 欺骗词法

欺骗词法作用域会导致性能下降。

1. `eval`函数: 可以接受一个字符串，并将其中内容视为好像在书写时就存在于程序中这个位置的代码;
2. `setTimeout(...)`、`setInterval(...)` 第一个参数可以是字符串;
3. `new Function(...)` 函数行为与上面类似;
4. `with` 关键字: 根据传递给它的对象创建一个全新的词法作用域。

JavaScript 引擎会在编译阶段进行数据项的性能优化，依赖于根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。若引擎遇到`eval`、`with`会认为这样的优化是无效的。

#### 2.1.2 函数作用域和块作用域

**函数作用域**: 属于这个函数的全部变量都可以在整个函数的范围内使用及复用。

最小授权或最小暴露原则指的是应该最小限度的暴露必要内容，将其它内容都‘隐藏’。将具体内容私有化，也可以b避免同名标识符之间的冲突。

> 区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置。若 function 是申明中第一个词，是函数声明，否则是函数表达式。

函数表达式可以匿名的，函数声明不可以省略函数名。使用场景如下：

1. 立即执行函数表达式（IIFE）;
2. 当作函数调用并传递参数进去;
3. 倒置代码运行顺序，UMD 项目中广泛使用。

```
// 更清晰，改进代码风格
(function IIFE(global) {

})(window);

// 倒置代码运行顺序
(function IIFE(def) {
  def(window);
})(function def(global) {

});
```

匿名函数使用方便，但有几点缺点需要考虑:
1. 匿名函数在栈追踪器中不会显示出有意义的函数名，使得调试很难；
2. 函数引用自身时只能使用过期的 arguments.callee 引用；
3. 可读性、可理解性降低。

始终使用函数表达式命名是一个最佳实践。

**块作用域**: 属于这个函数的全部变量都可以在整个函数的范围内使用及复用。

try/catch 结构在 catch 分句具有块作用域

`let`(`const`) 关键字可以将变量绑定到所在的任意作用域中，为其声明的变量隐式的劫持来所在的块作用域。let 进行的声明不会在块作用域中进行提升。

块作用域可以让引擎清楚知道没有必要继续保存某些变量，协助垃圾收集。

#### 2.1.3 作用域闭包

> 当函数可以记住并访问所在词法作用域，即使函数是在当前词法作用域外执行，这时就产生了闭包。

#### 2.1.4 模块

模块有两个特征，会创建涵盖整个包装函数内部作用域的闭包：
- 为创建内部作用域而调用一个包装函数
- 包装函数的返回值必须包括一个对内部函数的引用

```
var MyModules = (function Manager() {
  var modules = {};
  function define(name, deps, impl) {
    for (var i = 0; i < deps.length; i++) {
      deps[i] = modules[deps[i]];
    }
    modules[name] = impl.apply(impl, deps);
  }
  function get(name) {
    return modules[name];
  }

  return {
    define,
    get
  };
});

MyModules.define('bar', [''], function() {
  function hello(who) {
  }

  return {
    hello
  };
});

MyModules.define('foo', ['bar'], function() {
  function awesome(who) {
  }

  return {
    awesome
  };
});
```

基于函数的模块并不是一个能被静态识别的模式（编译器无法识别），API 语义只有在运行时才会被考虑进来，可以在运行时修改一个模块的 API；

ES6 模块的 API 是静态的（API 运行时不会改变），API引用不存在，编译器会在编译时就抛出‘早期’错误。模块文件中的内容会被当作好像包含在作用域闭包中一样来处理。

> 作用域分为词法作用域和动态作用域，JavaScript 中的作用域是词法作用域，动态作用域不关心函数和作用域是如何声明的，只关心从何处调用。作用域链是基于调用栈。

this 机制某种程度上像动态作用域。

#### 2.1.5 块作用域的替代方案

catch 分句是块级作用域，可实现。

```
{
  let a = 2;
  console.log(a); //2
}
console.log(a); // ReferenceError
```
```
{
  try {
    throw undefined;
  } catch (a) {
    a = 2;
  }
}
console.log(a);
```
`try/catch` 会带来性能问题。
